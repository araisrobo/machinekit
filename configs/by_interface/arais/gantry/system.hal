############################## Preload Component ################################################
# loadrt sub2            names=sub2.gantry
# loadrt blend           names=blend_y_vel
# loadrt blender         names=blender
# load 3 differentiators for accel signals
# loadrt ddt count=3
# load additional blocks
# loadrt hypot count=2
# Install debounce filters for transfer-signal
# loadrt debounce cfg="16"
# Set debounce time: number of servo-period
# setp debounce.0.delay 125
loadrt mult2 count=1
loadrt timedelay        names=son_delay
setp son_delay.on-delay     2
setp son_delay.off-delay    0

############################## Kinematics & Motion Controller ####################################
# Kinematics

loadrt [KINS]KINEMATICS
loadrt tp
##############################################################################
# motion controller, get name and thread periods from ini file
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_dio=[EMCMOT]NUM_DIO num_aio=[EMCMOT]NUM_AIO spindle_axis=[TRAJ]SPINDLE_AXIS num_joints=[KINS]JOINTS kins=[KINS]KINEMATICS tp=tp

# tick message flow: servo_tick => ring_jcmd => wosi_trans
# this creates the named ring ring_jcmd as record ring
newring ring_jcmd 16384 record
# servo_tick sends tick messages to ring_jcmd
loadrt servo_tick ring=ring_jcmd
# wosi_trans:
#   -I inifile: default to getenv(INI_FILE_NAME)
#   -r ring: ring buffer name
loadusr -W wosi_trans -r ring_jcmd


addf son_delay                  servo-thread
addf motion-command-handler     servo-thread
addf motion-controller          servo-thread
addf mult2.0                    servo-thread    # mult2 for spindle velocity to analog.out
# attach servo_tick after all joint commands are calculated
addf servo_tick                 servo-thread


# gantry-en: enable gantry compensator
setp wosi.gantry-en          1
# should AHC synchronized with S3 or ALWAYS-ON?
setp wosi.ahc.motion_s3      1
# send the position commands thru differentiators to
# generate velocity and accel signals
# net Xvel-fb     => ddt.0.in hypot.0.in0
# net Xacc        <= ddt.0.out 

# setp blend_y_vel.select 0.5
# net Yvel-fb     => blend_y_vel.in1
# net YYvel-fb    => blend_y_vel.in2
# net Yvel-fb-avg blend_y_vel.out => ddt.1.in hypot.0.in1
# net Yacc        <= ddt.1.out 

# net Zvel        => ddt.2.in hypot.1.in0
# net Zacc        <= ddt.2.out 

net accelState motion.accel-state => wosi.accel-state
net rev-input       => motion.tp-reverse-input

# TODO: Do we need current-vel for AHC?
net current-vel   wosi.motion.current-vel <= motion.current-vel


# create HAL signals for position commands from motion module
# connect position commands from motion module for "servo_tick => wosi_driver"
net j0-pos-cmd      joint.0.motor-pos-cmd       => servo_tick.j0-pos-cmd
net j1-pos-cmd      joint.1.motor-pos-cmd       => servo_tick.j1-pos-cmd
net j2-pos-cmd      joint.2.motor-pos-cmd       => servo_tick.j2-pos-cmd
net j3-pos-cmd      joint.3.motor-pos-cmd       => servo_tick.j3-pos-cmd
net j4-pos-cmd      joint.4.motor-pos-cmd       => servo_tick.j4-pos-cmd 
net j5-pos-cmd      joint.5.motor-pos-cmd       => servo_tick.j5-pos-cmd
net j6-pos-cmd      joint.6.motor-pos-cmd       => servo_tick.j6-pos-cmd
net update-pos-ack  motion.update-pos-ack       => servo_tick.update-pos-ack

# loop position commands back to motion module feedback
net j0-pos-fb   wosi.stepgen.0.position-fb => joint.0.motor-pos-fb
net j1-pos-fb   wosi.stepgen.1.position-fb => joint.1.motor-pos-fb
net j2-pos-fb   wosi.stepgen.2.position-fb => joint.2.motor-pos-fb
net j3-pos-fb   wosi.stepgen.3.position-fb => joint.3.motor-pos-fb
net j4-pos-fb   wosi.stepgen.4.position-fb => joint.4.motor-pos-fb
net j5-pos-fb   wosi.stepgen.5.position-fb => joint.5.motor-pos-fb
net j6-pos-fb   wosi.stepgen.6.position-fb => joint.6.motor-pos-fb

net J0vel-fb  wosi.stepgen.0.vel-fb
net J1vel-fb  wosi.stepgen.1.vel-fb
net J2vel-fb  wosi.stepgen.2.vel-fb
net J3vel-fb  wosi.stepgen.3.vel-fb
net J4vel-fb  wosi.stepgen.4.vel-fb
net J5vel-fb  wosi.stepgen.5.vel-fb
net J6vel-fb  wosi.stepgen.6.vel-fb
# net J7vel-fb  wosi.stepgen.7.vel-fb

# create signals for tool loading loopback
net tool-prep-loop iocontrol.0.tool-prepare iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change iocontrol.0.tool-changed

# # FIXME: do we still support this sync-in?
# # digital sync I/O signals
# net sync_in_trigger     motion.sync-in-trigger =>  wosi.sync.in.trigger
# net sync_in_index       motion.sync-in-index =>  wosi.sync.in.index
# net sync_in_wait_type   motion.sync-in-wait-type =>  wosi.sync.in.wait_type
# net sync_in_timeout     motion.sync-in-timeout =>  wosi.sync.in.timeout

# estop loopback
# net estop-loop iocontrol.0.user-enable-out iocontrol.0.emc-enable-in
# let ESTOP switch control ESTOP behavior
net din_0  => iocontrol.0.emc-enable-in

# # connect signals from FPGA.
# export ahc pins
net ahc-state   => wosi.ahc.state

# TODO: probed pos for gantry joint
net j0-probed-pos  wosi.stepgen.0.probed-pos => joint.0.probed-pos
net j1-probed-pos  wosi.stepgen.1.probed-pos => joint.1.probed-pos
net j2-probed-pos  wosi.stepgen.2.probed-pos => joint.2.probed-pos
net j3-probed-pos  wosi.stepgen.3.probed-pos => joint.3.probed-pos
net j4-probed-pos  wosi.stepgen.4.probed-pos => joint.4.probed-pos
net j5-probed-pos  wosi.stepgen.5.probed-pos => joint.5.probed-pos
net j6-probed-pos  wosi.stepgen.6.probed-pos => joint.6.probed-pos

net vx-cmd      => wosi.stepgen.0.vel-cmd
net vy-cmd      => wosi.stepgen.1.vel-cmd
net vz-cmd      => wosi.stepgen.3.vel-cmd

# SIM: setp joint.3.probed-pos -40

# # loop position commands back to motion module feedback
net J0-risc-pos-cmd wosi.stepgen.0.risc-pos-cmd => joint.0.risc-pos-cmd
net J1-risc-pos-cmd wosi.stepgen.1.risc-pos-cmd => joint.1.risc-pos-cmd
net J2-risc-pos-cmd wosi.stepgen.2.risc-pos-cmd => joint.2.risc-pos-cmd
net J3-risc-pos-cmd wosi.stepgen.3.risc-pos-cmd => joint.3.risc-pos-cmd
net J4-risc-pos-cmd wosi.stepgen.4.risc-pos-cmd => joint.4.risc-pos-cmd
net J5-risc-pos-cmd wosi.stepgen.5.risc-pos-cmd => joint.5.risc-pos-cmd
net J6-risc-pos-cmd wosi.stepgen.6.risc-pos-cmd => joint.6.risc-pos-cmd

# for usb-homing:
setp joint.0.home-sw-id                 [JOINT_0]HOME_SW_ID
net  [JOINT_0]HOME_SW_NET               joint.0.home-sw-in
net  j0-homing                          joint.0.homing => wosi.stepgen.0.homing
net  j0-risc-probe-vel                  joint.0.risc-probe-vel => servo_tick.j0-risc-probe-vel-i
net  j0-risc-probe-pin                  joint.0.risc-probe-pin => wosi.stepgen.0.risc-probe-pin
net  j0-risc-probe-type                 joint.0.risc-probe-type => wosi.stepgen.0.risc-probe-type

# for usb-homing:
setp joint.1.home-sw-id                 [JOINT_1]HOME_SW_ID
net  [JOINT_1]HOME_SW_NET               joint.1.home-sw-in
net  j1-homing                          joint.1.homing => wosi.stepgen.1.homing
net  j1-risc-probe-vel                  joint.1.risc-probe-vel => servo_tick.j1-risc-probe-vel-i
net  j1-risc-probe-pin                  joint.1.risc-probe-pin => wosi.stepgen.1.risc-probe-pin
net  j1-risc-probe-type                 joint.1.risc-probe-type => wosi.stepgen.1.risc-probe-type
setp rgantry.0.joint.01.home-offset     [AXIS_1]HOME_OFFSET_GANTRY_SLAVE

# for usb-homing(AXIS_Z, J3):
setp joint.2.home-sw-id                 [JOINT_2]HOME_SW_ID
net  [JOINT_2]HOME_SW_NET               joint.2.home-sw-in
net  j2-homing                          joint.2.homing => wosi.stepgen.2.homing
net  j2-risc-probe-vel                  joint.2.risc-probe-vel => servo_tick.j2-risc-probe-vel-i
net  j2-risc-probe-pin                  joint.2.risc-probe-pin => wosi.stepgen.2.risc-probe-pin
net  j2-risc-probe-type                 joint.2.risc-probe-type => wosi.stepgen.2.risc-probe-type

# for usb-homing(AXIS_A, J4):
setp joint.3.home-sw-id                 [JOINT_3]HOME_SW_ID
net  [JOINT_3]HOME_SW_NET               joint.3.home-sw-in
net  j3-homing                          joint.3.homing => wosi.stepgen.3.homing
net  j3-risc-probe-vel                  joint.3.risc-probe-vel => servo_tick.j3-risc-probe-vel-i
net  j3-risc-probe-pin                  joint.3.risc-probe-pin => wosi.stepgen.3.risc-probe-pin
net  j3-risc-probe-type                 joint.3.risc-probe-type => wosi.stepgen.3.risc-probe-type

# for usb-homing:
setp joint.4.home-sw-id                 [JOINT_4]HOME_SW_ID
net  [JOINT_4]HOME_SW_NET               joint.4.home-sw-in
net  j4-homing                          joint.4.homing => wosi.stepgen.4.homing
net  j4-risc-probe-vel                  joint.4.risc-probe-vel => servo_tick.j4-risc-probe-vel-i
net  j4-risc-probe-pin                  joint.4.risc-probe-pin => wosi.stepgen.4.risc-probe-pin
net  j4-risc-probe-type                 joint.4.risc-probe-type => wosi.stepgen.4.risc-probe-type

# for usb-homing:
setp joint.5.home-sw-id                 [JOINT_5]HOME_SW_ID
net  [JOINT_5]HOME_SW_NET               joint.5.home-sw-in
net  j5-homing                          joint.5.homing => wosi.stepgen.5.homing
net  j5-risc-probe-vel                  joint.5.risc-probe-vel => servo_tick.j5-risc-probe-vel-i
net  j5-risc-probe-pin                  joint.5.risc-probe-pin => wosi.stepgen.5.risc-probe-pin
net  j5-risc-probe-type                 joint.5.risc-probe-type => wosi.stepgen.5.risc-probe-type

# for usb-homing:
setp joint.6.home-sw-id                 [JOINT_6]HOME_SW_ID
net  [JOINT_6]HOME_SW_NET               joint.6.home-sw-in
net  j6-homing                          joint.6.homing => wosi.stepgen.6.homing
net  j6-risc-probe-vel                  joint.6.risc-probe-vel => servo_tick.j6-risc-probe-vel-i
net  j6-risc-probe-pin                  joint.6.risc-probe-pin => wosi.stepgen.6.risc-probe-pin
net  j6-risc-probe-type                 joint.6.risc-probe-type => wosi.stepgen.6.risc-probe-type

# RISC_CMD REQ and ACK
net update-pos-req      wosi.motion.update-pos-req   =>  motion.update-pos-req
# net rcmd-seq-num-req    wosi.motion.rcmd-seq-num-req =>  motion.rcmd-seq-num-req
# net rcmd-seq-num-ack    wosi.motion.rcmd-seq-num-ack <=  motion.rcmd-seq-num-ack
net rcmd-state          wosi.motion.rcmd-state       =>  motion.rcmd-state

# trigger type 
# 	0: or
# 	1: analog only
# 	2: digital only
# 	3: and
# cond(1): probe HIGH
setp wosi.trigger.din       51 
setp wosi.trigger.ain       2
setp wosi.trigger.type      2 
setp wosi.trigger.cond      1 
setp wosi.trigger.level     1000 
setp motion.trigger.din     51 
setp motion.trigger.ain     2 
setp motion.trigger.type    2 
setp motion.trigger.cond    1 
setp motion.trigger.level   1000 

# net machine_is_on       halui.machine.is-on 
net teleop_mode         wosi.motion.teleop-mode <= motion.teleop-mode
net coord_mode          wosi.motion.coord-mode <= motion.coord-mode
# for G38.X:
net probing             wosi.motion.probing <= motion.probing
net trigger_result      wosi.trigger.result => motion.trigger-result
net rtp_running         wosi.motion.rtp-running => motion.rtp-running

net ahc-doing   wosi.ahc.doing 
net ahc-level   wosi.ahc.level 

# jog-vel is mm/sec
setp            wosi.stepgen.0.jog-vel   [JOINT_0]JOG_VEL
setp            wosi.stepgen.1.jog-vel   [JOINT_1]JOG_VEL
setp            wosi.stepgen.2.jog-vel   [JOINT_1]JOG_VEL
setp            wosi.stepgen.3.jog-vel   [JOINT_3]JOG_VEL
setp            wosi.stepgen.4.jog-vel   [JOINT_4]JOG_VEL
setp            wosi.stepgen.5.jog-vel   [JOINT_5]JOG_VEL
# setp            wosi.stepgen.6.jog-vel   [AXIS_5]MAX_VELOCITY
# setp            wosi.stepgen.7.jog-vel   [AXIS_6]MAX_VELOCITY

# spindle control
# # refer to ysli 2015-07-26 for spindle speed scale
# # spindle-DAC = spindle-speed-cmd(RPM) * 65536 * 10000 / (20 * 560 * 1500) * 6(GEAR-BOX-RATIO)
# setp            mult2.0.in0                        234.05712
# net spindle-vel motion.spindle-speed-out        => mult2.0.in1
# net aout_01     wosi.analog.out.01              <= mult2.0.out
# net spindle-vel => motion.spindle-speed-in
# 
# # copy from sim_spindle_encoder.hal
# loadrt sim_spindle names=sim_spindle
# setp sim_spindle.scale 0.01666667
# loadrt near names=near_speed
# # encoder reset control
# # hook up motion controller's sync output
# net spindle-index-enable motion.spindle-index-enable <=> sim_spindle.index-enable
# # report our revolution count to the motion controller
# net spindle-pos sim_spindle.position-fb => motion.spindle-revs
# # spindle speed control
# net spindle-vel sim_spindle.velocity-cmd
# # for spindle velocity estimate
# net spindle-vel near_speed.in2
# # at-speed detection
# setp near_speed.scale 1.1
# setp near_speed.difference 10
# net spindle-vel => near_speed.in1
# net spindle-at-speed near_speed.out motion.spindle-at-speed
# addf near_speed servo-thread
# addf sim_spindle servo-thread
# # end of sim_spindle_encoder.hal
setp wosi.motion.spindle-joint-id [TRAJ]SPINDLE_JOINT
setp motion.spindle-joint-id [TRAJ]SPINDLE_JOINT

net bp-tick     <= wosi.bp-tick

