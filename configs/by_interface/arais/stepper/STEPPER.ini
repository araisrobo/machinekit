[KINS]
# X/J0, Y/J1, Y/J2, Z/J3, A/J4, S/J5
JOINTS =                6
AXES =                  4
KINEMATICS =            trivkins


[EMC]

# Name of machine, for use with display, etc.
MACHINE =               MEINAN/AR#1

#+ Debug level, 0 means no messages. See src/emc/nml_int/emcglb.h for others
DEBUG =		        0
# #define EMC_DEBUG_INTERP      0x00000100
# DEBUG =	                0x00000990

[DISPLAY]

# Name of display program, e.g., tkemc
# for mkwrapper, need to do "loadusr haltalk" at system.py
DISPLAY = mkwrapper
# DISPLAY = mkwrapper --debug
# DISPLAY = axis

# Cycle time, in seconds, that display will sleep between polls
CYCLE_TIME =            0.100

# Path to help file
HELP_FILE =             tklinucnc.txt

# Initial display setting for position, RELATIVE or MACHINE
POSITION_OFFSET =       RELATIVE

# Initial display setting for position, COMMANDED or ACTUAL
POSITION_FEEDBACK =     ACTUAL

# Highest value that will be allowed for feed override, 1.0 = 100%
MAX_FEED_OVERRIDE =     1.5

# Display unit for velocity values
TIME_UNITS = minute

# Prefix to be used
PROGRAM_PREFIX = ./nc_files

# Introductory graphic
INTRO_GRAPHIC =
INTRO_TIME =            0

# Increments for the JOG section
INCREMENTS = 0.01 0.1 1

OPEN_FILE =

MIN_VELOCITY = 1.0

USER_ID = 2

[FILTER]
PROGRAM_EXTENSION = .png,.gif,.jpg Grayscale Depth Image
PROGRAM_EXTENSION = .py Python Script
PROGRAM_EXTENSION = .gcode RepRap Flavour GCode

png = image-to-gcode
gif = image-to-gcode
jpg = image-to-gcode
py = python
gcode = gcode-to-ngc

# Task controller section -----------------------------------------------------
[TASK]

# Name of task controller program, e.g., milltask
TASK =                  milltask

# Cycle time, in seconds, that task controller will sleep between polls
CYCLE_TIME =            0.010


# Part program interpreter section 
[RS274NGC]

# File containing interpreter variables
PARAMETER_FILE =	system.var

LOG_LEVEL = 0

# SUBROUTINE_PATH = nc_subroutines:../common_nc_subs
# RESUME_STARTUP_CODE = M4
# optional features - a bit mask to selectively turn on experimental/dubious features
# see 
# RETAIN_G43           0x00000001
# OWORD_N_ARGS         0x00000002
# INI_VARS             0x00000004
# HAL_PIN_VARS         0x00000008
# NO_DOWNCASE_OWORD    0x00000010

# turn on all optional features except RETAIN_G43
FEATURES=30
# add n_args parameter: 2
#     A called subroutine can determine the number of actual positional parameters passed by inspecting the #<n_args> parameter.
# enable #<_ini[section]name> read only variables: 4
#     if set, the interpreter will fetch read-only values from the ini file through this special variable syntax.
# enable #<_hal[Hal item]> read only variables: 8
#     if set, the interpreter will fetch read-only values from HAL file through this special variable syntax.
# preserve case in O-word names within comments: 16
#     if set, enables reading of mixed-case HAL items in structured comments like (debug, #<_hal[MixedCaseItem]). Really a kludge which should go away.

# Motion control section 
[EMCMOT]

EMCMOT =                motmod
LOG_LEVEL = 0

# Timeout for comm to emcmot, in seconds
COMM_TIMEOUT =          1.0

# Interval between tries to emcmot, in seconds
COMM_WAIT =             0.010

# Servo task period, in nanoseconds
SERVO_PERIOD =		655360


# Hardware Abstraction Layer section
[HAL]

# The run script first uses halcmd to execute any HALFILE
# files, and then to execute any individual HALCMD commands.

# list of hal config files to run through halcmd
# files are executed in the order in which they appear

HALFILE = system.hal
HALFILE = system.py



[TRAJ]
#+ machine specific settings
# AXES: not necessary if "COORDINATES" was set
AXES =		                5
COORDINATES =		        X Y Z A B
HOME =                          0 0 0 0 0
LINEAR_UNITS =		        mm
ANGULAR_UNITS =                 degree

CYCLE_TIME =             0.010
DEFAULT_VELOCITY =       9
DEFAULT_ACCELERATION =   30
DEFAULT_JERK =           160
MAX_VELOCITY =           9
MAX_ACCELERATION =       30
MAX_JERK	 =	 160
TIME_UNITS =             s

ARC_BLEND_ENABLE =      1
ARC_BLEND_FALLBACK_ENABLE = 0
ARC_BLEND_OPTIMIZATION_DEPTH = 50
ARC_BLEND_GAP_CYCLES = 4 # (How short the previous segment must be before the trajectory planner "consumes" it)
ARC_BLEND_RAMP_FREQ = 20 # (This is a "cutoff" frequency for using ramped velocity)
USB_MOTION_ENABLE =     1

# map AXIS_4(A) as spindleAxis
SPINDLE_AXIS =          4
# map JOINT_5 as spindleJoint
SPINDLE_JOINT =         5

# X/J0
[AXIS_0]
TYPE =                          LINEAR
HOME =                          0    
MAX_VELOCITY =                  9.5
MAX_ACCELERATION =              33
MAX_JERK	 =	        170
BACKLASH =                      0.000
# set both MIN and MAX LIMIT to 0 to disable soft limit checking
MIN_LIMIT =                     0
MAX_LIMIT =                     0
# set both FERROR and MIN_FERROR to 0 to disable FERROR detection
FERROR =                        0
MIN_FERROR =                    0

HOME_OFFSET =                   0    
HOME_SEARCH_VEL =               10.5
HOME_LATCH_VEL =                -1.0
HOME_FINAL_VEL  =               10.0
HOME_USE_INDEX =                YES
HOME_IGNORE_LIMITS =            YES
HOME_SEQUENCE =                 4 


# Y/J1, Y/J2
[AXIS_1]
TYPE =                          LINEAR
HOME =                          0.000
MAX_VELOCITY =                  9.5
MAX_ACCELERATION =              33 
MAX_JERK =	                170 
BACKLASH =                      0.000
MIN_LIMIT =                     0
MAX_LIMIT =                     0
FERROR =                        0.0
MIN_FERROR =                    0.0

HOME_OFFSET =                   0.0
HOME_SEARCH_VEL =              -25.5
HOME_LATCH_VEL =                5.0
HOME_FINAL_VEL  =               10.0
HOME_USE_INDEX =                NO
HOME_IGNORE_LIMITS =            YES
HOME_SEQUENCE =                 3


# Z/J3
[AXIS_2]
TYPE =                          LINEAR
HOME =                          0.000
MAX_VELOCITY =                  9.5
MAX_ACCELERATION =              33  
MAX_JERK =	                170  
BACKLASH =                      0.000
MIN_LIMIT =                     0
MAX_LIMIT =                     0
FERROR =                        0
MIN_FERROR =                    0

HOME_OFFSET =                   0
# HOME_SEARCH_VEL =               0
# HOME_LATCH_VEL =                0
# HOME_FINAL_VEL  =               0
HOME_SEARCH_VEL =               -15.5
HOME_LATCH_VEL =                5.0
HOME_FINAL_VEL  =               10.0 

HOME_USE_INDEX =                NO
HOME_IGNORE_LIMITS =            YES 
HOME_SEQUENCE =                 2

# A/J4
[AXIS_3]
TYPE =                          LINEAR
HOME =                          0.000
MAX_VELOCITY =                  633
MAX_ACCELERATION =              2216
MAX_JERK =	                11083
BACKLASH =                      0.000
MIN_LIMIT =                     0
MAX_LIMIT =                     0
FERROR =                        0
MIN_FERROR =                    0

HOME_OFFSET =                   0
# HOME_SEARCH_VEL =               0
# HOME_LATCH_VEL =                0
# HOME_FINAL_VEL  =               0
HOME_SEARCH_VEL =               15.5
HOME_LATCH_VEL =                -5.0
HOME_FINAL_VEL  =               10.0 

HOME_USE_INDEX =                 NO 
HOME_IGNORE_LIMITS =             YES
HOME_SEQUENCE =                 1


# B/J5
[AXIS_4]
TYPE =                          LINEAR
HOME =                          0.000
MAX_VELOCITY =                  49.5
MAX_ACCELERATION =              195
MAX_JERK	 =		870
BACKLASH =                      0.000
MIN_LIMIT =                     0
MAX_LIMIT =                     0
FERROR =                        0
MIN_FERROR =                    0

HOME_OFFSET =                   0.0
HOME_SEARCH_VEL =               0.0 
HOME_LATCH_VEL =                0.0 
HOME_FINAL_VEL =                0.0 

HOME_USE_INDEX =                 NO 
HOME_IGNORE_LIMITS =             YES
HOME_SEQUENCE =                 0

# AXIS is responsible for HOMING/LIMIT/BACKLASH; JOINT is not.
# X/J0
[JOINT_0]
TYPE =                          LINEAR
MAX_VELOCITY =                  10  
MAX_ACCELERATION =              35
MAX_JERK	 =	        175

#17bit w/ 35:1 Gearbox: 
INPUT_SCALE =                   25600       
#13bit w/ 35:1 Gearbox: 
# INPUT_SCALE =                   49715.90909
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


# Y/J1
[JOINT_1]
TYPE =                          LINEAR
MAX_VELOCITY =                  10  
MAX_ACCELERATION =              35
MAX_JERK	 =	        175

#17-bit: 
# INPUT_SCALE =                   11218.076
INPUT_SCALE =                   25600       
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


# Y/J2
[JOINT_2]
TYPE =                          LINEAR
MAX_VELOCITY =                  10  
MAX_ACCELERATION =              35
MAX_JERK	 =	        175

#17-bit: 
# INPUT_SCALE =                   11218.076
INPUT_SCALE =                   25600       
# INPUT_SCALE =                   -51200
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


# Z/J3
[JOINT_3]
TYPE =                          LINEAR
MAX_VELOCITY =                  10 
MAX_ACCELERATION =              35
MAX_JERK =	                175  

INPUT_SCALE =                   25600
# INPUT_SCALE =                   2204.72441
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


# A/J4
[JOINT_4]
TYPE =                          ANGULAR
MAX_VELOCITY =                  50   
MAX_ACCELERATION =              175
MAX_JERK	 =		875

INPUT_SCALE =                   10000.0
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


# JOINT_5: RESERVED JOINT
[JOINT_5]
TYPE =                          ANGULAR
MAX_VELOCITY =                  50   
MAX_ACCELERATION =              175
MAX_JERK	 =		875

INPUT_SCALE =                   10000.0
ENC_SCALE =                     1.0

FERROR =                        0
MIN_FERROR =                    0


[P0]
X = 0.0
Y = 0.0


###############################################################################
# section for main IO controller parameters 
###############################################################################
[EMCIO]

# Name of IO controller program, e.g., io
EMCIO =                 io

# cycle time, in seconds
CYCLE_TIME =            0.100

# tool table file
TOOL_TABLE =		tool.tbl

[ARAIS]
DRIVER  = wosi
BOARD   = ar11-rpi2
FPGA    = ar11_top.bit
RISC    = css.bin

##########################################################
# Parameters:                                            # 
# (unit for all gains: 1/65536)                          #
# P   : p gain (16.16)                                   #           
# I   : i gain (16.16)                                   #  
# D   : d gain (16.16)                                   #   
# FF0, FF1, FF2: feedforward gains (16.16)               #  
# DB  : deadband (32.0 )                                 #
# BIAS: input bias (obsolete)                            #
# M_ER: max error (32.0 )                                #
# M_EI: max error_i (32.0 )                              #  
# M_ED: max error_d (32.0 )                              #    
# MCD : max cmd derivative (16.16)                       #     
# MCDD: max 2nd order command derivative (16.16)         #        
# MO  : max output (16.16)                               #      
##########################################################
# J0/X, J1/Y, J2/YY, J3/Z, J4/A, J5/SPINDLE
#                    P    I      D  FF0    FF1  FF2       DB  BI            M_ER  M_EI M_ED MCD MCDD    MO 
# J0_PID      =    2250,   0,     0,   0, 50000,   0,      20,  0,              0,    0,   0,  0,  0,     0
# J1_PID      =     250,   0,     0,   0, 20000,   0, 1114112,  0,              0,    0,   0,  0,  0,     0
# J2_PID      =     250,   0,     0,   0, 20000,   0, 1114112,  0,              0,    0,   0,  0,  0,     0
# J3_PID      =    7250, 100,     0,   0, 35000,   0,       2,  0,              0,    0,   0,  0,  0,     0
# J4_PID      =    7250, 100,     0,   0, 35000,   0,       2,  0,              0,    0,   0,  0,  0,     0
# J5_PID      =     100,   0,     0,   0, 60000,   0,     200,  0,              0,1000000,   0,  0,  0,     0
J0_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
J1_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
J2_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
J3_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
J4_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
J5_PID      =       0,   0,     0,   0, 65536,   0,       0,  0,              0,    0,   0,  0,  0,     0
# J6_PID maps to GANTRY_PID
J6_PID      =       0,   0,     0,   0,     0,   0,       0,  0,              0,    0,   0,  0,  0,     0
# J7_PID maps to AHC_PID                                         M_ER=200*65536
# AHC_PID   =    9000,   0,     0,   0,     0,   0,       0,  0,       13107200,    0,   0,  0,  0,     0
J7_PID      =       0,   0,     0,   0,     0,   0,       0,  0,              0,    0,   0,  0,  0,     0

# AHC_CH      =  1
# AHC_JNT     =  3
# AHC_POLARITY = POSITIVE

# PULSE_TYPE(A): AB-PHASE
# PULSE_TYPE(S): STEP-DIR
# PULSE_TYPE(P): PWM-DIR
# PULSE_TYPE = p,a,a,p,p,p
PULSE_TYPE = s,s,s,s,s,s
# PULSE_TYPE = p,p,p,p,p,p 
# ENC_TYPE(l): LOOP-BACK PULSE_CMD to ENCODER (fake ENCODER counts)
# ENC_TYPE(a): REAL ENCODER counts, AB-Phase
# ENC_TYPE(s): REAL ENCODER counts, STEP-DIR
ENC_TYPE = l,l,l,l,l,l
# ENC_TYPE = a,a,a,a,a,a
# ENC_POL(p): POSITIVE POLARITY for ENCODER SIGNAL
# ENC_POL(n): NEGATIVE POLARITY for ENCODER SIGNAL
ENC_POL = p,p,p,p,p,p
GANTRY_POLARITY =  -1

# LSP_ID, LSN_ID. ALR_ID: 
#   the GPIO id for LSP/LSN/ALR signals
#   set to 255 to disable LSP/LSN/ALR checking
# TODO: there is a wiring bug for J3.LSP sensor
# LSP_ID = 7,9,11,255,255,255
# LSN_ID = 255,10,12,255,255,255
# ALR_ID = 1,2,3,4,5,255
LSP_ID = 255,255,255,255,255,255
LSN_ID = 255,255,255,255,255,255
ALR_ID = 255,255,255,255,255,255

# remote-control
# JSP_ID = "58,60,60,56,255,255"
# JSN_ID = "59,61,61,57,255,255"
JSP_ID = 255,255,255,255,255,255
JSN_ID = 255,255,255,255,255,255
# START = din_62
# STOP  = din_63 

J0_HOME_SW_ID   =  7
J1_HOME_SW_ID   = 10
J2_HOME_SW_ID   = 12
J3_HOME_SW_ID   = 14
J4_HOME_SW_ID   = 15
J5_HOME_SW_ID   = 16
# artek: our home switches are low-active
#        usb-homeing.c requires home-switches to be active-high
J0_HOME_SW_NET  = din_07_not
J1_HOME_SW_NET  = din_10_not
J2_HOME_SW_NET  = din_12_not
J3_HOME_SW_NET  = din_14_not
J4_HOME_SW_NET  = din_15_not
J5_HOME_SW_NET  = din_16_not


# ALR_OUTPUT: the DOUT port value when ALARM is triggered
ALR_OUTPUT_0 = 0x00000000
ALR_OUTPUT_1 = 0x00000000
# ALARM_EN: ESTOP_EN/DIN[0] enable bit
ALARM_EN = 0

# DAC_CTRL_REG: the DAC control register for AR09 (4 channels)
#                 CH0,   CH1,   CH2,   CH3
DAC_CTRL_REG = 0x1003,0x1006,0x1006,0x1001
# CH0: 0x1001(0~10V)
# CH0: 0x1002(-5~5V)
# CH0: 0x1003(-10~10V)
# CH1: 0x1006(0~20mA)
# CH2: 0x1006(0~20mA)
# CH3: 0x1001(0~10V)
